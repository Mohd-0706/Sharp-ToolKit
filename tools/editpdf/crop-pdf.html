<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF Crop Tool</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap">
  <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">

  <style>
    /* Enhanced Base Styles & Variables */
    :root {
      /* Color Palette */
      --primary-color: #8a2be2;
      --primary-dark: #7b1fa2;
      --primary-light: rgba(138, 43, 226, 0.1);
      --secondary-color: #ff7f50;
      --accent-color: #32cd32;
      --success-color: #4ade80;
      --warning-color: #f59e0b;
      --danger-color: #f43f5e;
      --dark-color: #1e293b;
      --light-color: #f8f8f8;
      --gray-color: #64748b;
      --gray-light: #e2e8f0;

      /* Text */
      --text-color: #1e293b;
      --text-light: #64748b;
      --text-dark: #0f172a;
      --text-white: #ffffff;

      /* Backgrounds */
      --bg-light: #f8f8f8;
      --bg-white: #ffffff;
      --bg-dark: #0f172a;
      --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
      --bg-gradient-dark: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);

      /* Borders */
      --border-radius: 12px;
      --border-radius-sm: 8px;
      --border-radius-lg: 16px;
      --border-color: #e2e8f0;

      /* Shadows */
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --shadow-xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      --shadow-inset: inset 0 2px 4px 0 rgba(0, 0, 0, 0.05);

      /* Transitions */
      --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      --transition-fast: all 0.15s cubic-bezier(0.25, 0.8, 0.25, 1);
      --transition-slow: all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
      --transition-bounce: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    [data-theme="dark"] {
      --text-color: #e2e8f0;
      --text-light: #94a3b8;
      --text-dark: #f8fafc;
      --bg-light: #0f172a;
      --bg-white: #1e293b;
      --bg-gradient: var(--bg-gradient-dark);
      --border-color: #334155;
      --gray-light: #334155;
    }

    /* Base Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      font-size: 16px;
      scroll-behavior: smooth;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body {
      font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: var(--bg-gradient);
      color: var(--text-color);
      line-height: 1.6;
      transition: var(--transition-slow);
      overflow-x: hidden;
      min-height: 100vh;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      font-weight: 700;
      line-height: 1.2;
      margin-bottom: 1rem;
      color: var(--text-dark);
      letter-spacing: -0.025em;
    }

    [data-theme="dark"] h1,
    [data-theme="dark"] h2,
    [data-theme="dark"] h3,
    [data-theme="dark"] h4,
    [data-theme="dark"] h5,
    [data-theme="dark"] h6 {
      color: var(--text-white);
    }

    p {
      margin-bottom: 1rem;
      color: var(--text-light);
      font-weight: 400;
    }

    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1.5rem;
    }

    /* Header Styles */
    .site-header {
      position: sticky;
      top: 0;
      z-index: 1000;
      background-color: rgba(255, 255, 255, 0.97);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: var(--shadow-sm);
      transition: var(--transition-slow);
      will-change: transform, backdrop-filter, background-color;
      padding: 1rem 0;
    }

    [data-theme="dark"] .site-header {
      background-color: rgba(15, 23, 42, 0.97);
    }

    .header-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 1.5rem;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-dark);
      transition: var(--transition);
      text-decoration: none;
    }

    .logo span {
      color: var(--primary-color);
      font-weight: 800;
    }

    [data-theme="dark"] .logo {
      color: var(--text-white);
    }

    .logo-icon {
      font-size: 1.5rem;
      color: var(--primary-color);
      transition: var(--transition);
    }

    /* Theme Toggle Switch */
    .theme-switch {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .theme-switch-label {
      font-size: 0.9rem;
      color: var(--text-light);
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--gray-light);
      transition: var(--transition);
      border-radius: 24px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: var(--transition);
      border-radius: 50%;
    }

    input:checked+.slider {
      background-color: var(--primary-color);
    }

    input:checked+.slider:before {
      transform: translateX(26px);
    }

    /* Main Content */
    .main-content {
      padding: 3rem 0;
    }

    .section-header {
      text-align: center;
      margin-bottom: 3rem;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
      position: relative;
    }

    .section-header h1 {
      font-size: 2.5rem;
      margin-bottom: 1rem;
      position: relative;
      display: inline;
      background: linear-gradient(90deg, var(--danger-color), var(--primary-color), var(--secondary-color));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: gradientShift 8s ease infinite;
      background-size: 200% 200%;
    }

    @keyframes gradientShift {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    /* Upload Section */
    .upload-section {
      margin-bottom: 3rem;
    }

    .upload-box {
      border: 2px dashed var(--border-color);
      padding: 3rem 2rem;
      text-align: center;
      border-radius: var(--border-radius);
      background: var(--bg-white);
      transition: var(--transition);
      cursor: pointer;
      position: relative;
      overflow: hidden;
      max-width: 800px;
      margin: 0 auto;
      box-shadow: var(--shadow);
    }

    .upload-box:hover {
      border-color: var(--primary-color);
      transform: translateY(-3px);
      box-shadow: var(--shadow-lg);
      background-color: var(--primary-light);
    }

    .upload-box i {
      font-size: 3rem;
      color: var(--primary-color);
      margin-bottom: 1rem;
      transition: var(--transition);
    }

    .upload-box:hover i {
      transform: scale(1.1);
    }

    .upload-box h3 {
      margin-bottom: 0.5rem;
      color: var(--text-color);
    }

    .upload-box p {
      color: var(--text-light);
    }

    .upload-box input[type="file"] {
      display: none;
    }

    /* Progress Bar */
    .progress-container {
      width: 100%;
      height: 6px;
      background: rgba(138, 43, 226, 0.1);
      border-radius: 3px;
      margin-top: 1.5rem;
      overflow: hidden;
      display: none;
    }

    .progress-bar {
      height: 100%;
      width: 0;
      background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
      transition: width 0.3s ease;
      border-radius: 3px;
    }

    /* PDF Preview Section */
    .preview-section {
      margin-top: 3rem;
      display: none;
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .preview-title {
      font-size: 1.5rem;
      color: var(--text-dark);
    }

    .preview-actions {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    /* Canvas Container */
    #canvas-container {
      position: relative;
      display: inline-block;
      border: 1px solid var(--border-color);
      cursor: crosshair;
      margin: 0 auto;
      max-width: 100%;
      overflow: auto;
      background: var(--bg-white);
      box-shadow: var(--shadow);
      border-radius: var(--border-radius-sm);
    }

    canvas {
      display: block;
      max-width: 100%;
    }

    .crop-area {
      position: absolute;
      border: 2px dashed red;
      background: rgba(255, 0, 0, 0.15);
      box-sizing: border-box;
      cursor: move;
    }

    .crop-area.selected {
      border-color: var(--primary-color);
      background: rgba(138, 43, 226, 0.15);
    }

    .handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: var(--primary-color);
      border: 1px solid white;
      box-sizing: border-box;
      cursor: pointer;
    }

    .handle.nw {
      top: -5px;
      left: -5px;
      cursor: nwse-resize;
    }

    .handle.ne {
      top: -5px;
      right: -5px;
      cursor: nesw-resize;
    }

    .handle.sw {
      bottom: -5px;
      left: -5px;
      cursor: nesw-resize;
    }

    .handle.se {
      bottom: -5px;
      right: -5px;
      cursor: nwse-resize;
    }

    /* Controls */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1.5rem;
      align-items: center;
    }

    .controls select {
      padding: 0.75rem 1rem;
      border-radius: var(--border-radius-sm);
      border: 1px solid var(--border-color);
      background: var(--bg-white);
      color: var(--text-color);
      font-family: inherit;
      font-size: 1rem;
      transition: var(--transition);
    }

    .controls select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(138, 43, 226, 0.2);
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.75rem 1.5rem;
      border-radius: var(--border-radius);
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      position: relative;
      overflow: hidden;
      border: none;
      outline: none;
    }

    .btn-primary {
      background-color: var(--primary-color);
      color: white;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
      z-index: 1;
    }

    .btn-primary:before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
      z-index: -1;
      opacity: 0;
      transition: var(--transition);
    }

    .btn-primary:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow: var(--shadow-lg);
    }

    .btn-primary:hover:before {
      opacity: 1;
    }

    .btn-primary:active {
      transform: translateY(1px);
      box-shadow: var(--shadow-sm);
    }

    .btn-outline {
      background-color: transparent;
      color: var(--primary-color);
      border: 2px solid var(--primary-color);
      position: relative;
      overflow: hidden;
      z-index: 1;
    }

    .btn-outline:before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--primary-color);
      z-index: -1;
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 0.3s ease;
    }

    .btn-outline:hover {
      color: white;
      transform: translateY(-3px);
      box-shadow: var(--shadow);
    }

    .btn-outline:hover:before {
      transform: scaleX(1);
    }

    .btn-outline:active {
      transform: translateY(1px);
    }

    .btn-sm {
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
    }

    .btn i {
      font-size: 0.9em;
    }

    /* Status Message */
    .status-message {
      padding: 1rem;
      border-radius: var(--border-radius-sm);
      margin: 1rem 0;
      display: none;
      font-weight: 500;
      text-align: center;
    }

    .status-message.error {
      background-color: rgba(244, 63, 94, 0.1);
      color: var(--danger-color);
      border-left: 4px solid var(--danger-color);
      display: block;
    }

    .status-message.success {
      background-color: rgba(74, 222, 128, 0.1);
      color: var(--success-color);
      border-left: 4px solid var(--success-color);
      display: block;
    }

    /* Loading Spinner */
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(138, 43, 226, 0.1);
      border-top: 4px solid var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 2rem auto;
      display: none;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Zoom Controls */
    .zoom-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 0.5rem;
      z-index: 10;
    }

    .zoom-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--bg-white);
      color: var(--primary-color);
      border: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
      transition: var(--transition);
    }

    .zoom-btn:hover {
      background: var(--primary-color);
      color: white;
      transform: translateY(-2px);
      box-shadow: var(--shadow);
    }

    .zoom-value {
      background: var(--bg-white);
      padding: 0.5rem 1rem;
      border-radius: var(--border-radius);
      font-weight: 500;
      box-shadow: var(--shadow-sm);
      display: flex;
      align-items: center;
    }


    /* Back Button */
    .back-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      background-color: var(--primary-color);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-lg);
      z-index: 100;
      transition: var(--transition);
      text-decoration: none;
    }

    .back-btn:hover {
      transform: translateY(-3px) scale(1.1);
      box-shadow: var(--shadow-xl);
    }

    /* Page Navigation */
    .page-navigation {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin: 1.5rem 0;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .section-header h1 {
        font-size: 2rem;
      }

      .controls {
        flex-direction: column;
        align-items: stretch;
      }

      .preview-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .preview-actions {
        width: 100%;
      }

      .btn {
        width: 100%;
      }
    }

    @media (max-width: 480px) {
      .section-header h1 {
        font-size: 1.8rem;
      }

      .btn {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
      }
    }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="header-container">
      <a href="/PDFTOOLS/index.html" class="logo">
        <i class="fas fa-file-pdf logo-icon"></i>
        <span>PDF Tools</span>
      </a>
      <div class="theme-switch">
        <span class="theme-switch-label"></span>
        <label class="switch">
          <input type="checkbox" id="themeToggle">
          <span class="slider"></span>
        </label>
      </div>
    </div>
  </header>

  <main class="main-content">
    <div class="container">
      <div class="section-header" data-aos="fade-down">
        <h1>PDF Crop Tool</h1>
        <p>Upload your PDF file and crop specific areas with our intuitive tool</p>
      </div>

      <section class="upload-section" data-aos="fade-up" data-aos-delay="100">
        <div class="upload-box" id="uploadBox" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)"
          ondrop="handleDrop(event)">
          <i class="fas fa-cloud-upload-alt"></i>
          <h3>Upload PDF File</h3>
          <p>Click to browse or drag & drop your PDF file here</p>
          <input type="file" id="pdfUpload" accept="application/pdf" />
          <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
          </div>
        </div>
        <div class="status-message" id="statusMessage"></div>
      </section>

      <div class="preview-actions">
        <button class="btn btn-outline" id="undoBtn" disabled>
          <i class="fas fa-undo"></i> Undo
        </button>
        <button class="btn btn-outline" id="redoBtn" disabled>
          <i class="fas fa-redo"></i> Redo
        </button>
        <button class="btn btn-outline" id="resetBtn">
          <i class="fas fa-trash-alt"></i> Reset
        </button>
        <button class="btn btn-primary" id="applyCrop">
          <i class="fas fa-crop"></i> Apply Crop & Download
        </button>
      </div>
    </div>

    <div class="controls">
      <select id="pageSelect">
        <option value="current">Current Page</option>
        <option value="all">All Pages</option>
      </select>
      <div class="page-navigation">
        <button class="btn btn-outline btn-sm" id="prevPage" disabled>
          <i class="fas fa-chevron-left"></i> Previous
        </button>
        <span id="pageInfo">Page 1 of 1</span>
        <button class="btn btn-outline btn-sm" id="nextPage" disabled>
          Next <i class="fas fa-chevron-right"></i>
        </button>
      </div>
    </div>

    <div class="spinner" id="loadingSpinner"></div>

    <div id="canvas-container-wrapper" style="text-align: center; position: relative;">
      <div id="canvas-container">
        <canvas id="pdfCanvas"></canvas>
      </div>
      <div class="zoom-controls">
        <button class="zoom-btn" id="zoomOutBtn" title="Zoom Out">
          <i class="fas fa-search-minus"></i>
        </button>
        <span class="zoom-value" id="zoomValue">150%</span>
        <button class="zoom-btn" id="zoomInBtn" title="Zoom In">
          <i class="fas fa-search-plus"></i>
        </button>
        <button class="zoom-btn" id="resetZoomBtn" title="Reset Zoom">
          <i class="fas fa-sync-alt"></i>
        </button>
      </div>
    </div>
    </div>
  </main>

  <a href="/PDFTOOLS/index.html" class="back-btn">
    <i class="fas fa-arrow-left"></i>
  </a>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>

  <script>
    // Initialize AOS (Animate On Scroll)
    AOS.init({
      duration: 800,
      easing: 'ease-in-out',
      once: true
    });

    // Set PDF.js worker path
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    // DOM Elements
    const pdfUpload = document.getElementById('pdfUpload');
    const uploadBox = document.getElementById('uploadBox');
    const previewSection = document.getElementById('previewSection');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const statusMessage = document.getElementById('statusMessage');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const applyCropBtn = document.getElementById('applyCrop');
    const pageSelect = document.getElementById('pageSelect');
    const prevPageBtn = document.getElementById('prevPage');
    const nextPageBtn = document.getElementById('nextPage');
    const pageInfo = document.getElementById('pageInfo');
    const themeToggle = document.getElementById('themeToggle');
    const canvas = document.getElementById('pdfCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const resetBtn = document.getElementById('resetBtn');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const resetZoomBtn = document.getElementById('resetZoomBtn');
    const zoomValue = document.getElementById('zoomValue');

    // Global variables
    let pdfDoc = null;
    let currentPage = 1;
    let scale = 1.5;
    const MIN_SCALE = 0.5;
    const MAX_SCALE = 3.0;
    const SCALE_STEP = 0.25;

    // Crop box data and state
    let cropBoxes = []; // array of {left, top, width, height}
    let selectedBoxIndex = -1;
    let isDrawing = false;
    let startX = 0, startY = 0;
    let isDraggingBox = false;
    let dragOffsetX = 0, dragOffsetY = 0;
    let isResizing = false;
    let resizeHandle = null;

    // Undo/Redo stacks
    let undoStack = [];
    let redoStack = [];

    // Check for saved theme preference
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);
    if (savedTheme === 'dark') {
      themeToggle.checked = true;
    }

    // Event Listeners
    uploadBox.addEventListener('click', () => pdfUpload.click());
    pdfUpload.addEventListener('change', handleFileSelect);
    undoBtn.addEventListener('click', undoAction);
    redoBtn.addEventListener('click', redoAction);
    applyCropBtn.addEventListener('click', applyCrop);
    prevPageBtn.addEventListener('click', goToPrevPage);
    nextPageBtn.addEventListener('click', goToNextPage);
    themeToggle.addEventListener('change', toggleTheme);
    resetBtn.addEventListener('click', resetCropBoxes);
    zoomInBtn.addEventListener('click', zoomIn);
    zoomOutBtn.addEventListener('click', zoomOut);
    resetZoomBtn.addEventListener('click', resetZoom);

    // Functions
    function handleFileSelect(e) {
      const file = e.target.files[0];
      if (file) {
        processPDFFile(file);
      }
    }

    function handleDragOver(e) {
      e.preventDefault();
      e.stopPropagation();
      uploadBox.style.borderColor = 'var(--primary-color)';
      uploadBox.style.backgroundColor = 'var(--primary-light)';
    }

    function handleDragLeave(e) {
      e.preventDefault();
      e.stopPropagation();
      uploadBox.style.borderColor = 'var(--border-color)';
      uploadBox.style.backgroundColor = 'var(--bg-white)';
    }

    function handleDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      handleDragLeave(e);

      const file = e.dataTransfer.files[0];
      if (file && file.type === 'application/pdf') {
        processPDFFile(file);
      } else {
        showStatusMessage('Please upload a valid PDF file', 'error');
      }
    }

    async function processPDFFile(file) {
      // Validate file
      if (file.type !== 'application/pdf') {
        showStatusMessage('Please upload a valid PDF file', 'error');
        return;
      }

      try {
        // Show loading state
        loadingSpinner.style.display = 'block';
        progressContainer.style.display = 'block';
        previewSection.style.display = 'none';
        cropBoxes = [];
        selectedBoxIndex = -1;
        clearUndoRedo();

        // Read file as array buffer
        const reader = new FileReader();
        reader.onload = async function (e) {
          try {
            const typedArray = new Uint8Array(e.target.result);

            // Load PDF document
            pdfDoc = await pdfjsLib.getDocument({ data: typedArray }).promise;

            // Update progress bar
            progressBar.style.width = '100%';

            // Update page navigation
            updatePageNavigation();

            // Render first page
            await renderPage(currentPage);

            // Show preview section
            setTimeout(() => {
              progressContainer.style.display = 'none';
              progressBar.style.width = '0';
              loadingSpinner.style.display = 'none';
              previewSection.style.display = 'block';
              showStatusMessage('PDF loaded successfully!', 'success');
            }, 500);

          } catch (error) {
            console.error('Error processing PDF:', error);
            showStatusMessage('Error processing PDF file', 'error');
            resetLoadingState();
          }
        };

        reader.onerror = function () {
          showStatusMessage('Error reading file', 'error');
          resetLoadingState();
        };

        reader.readAsArrayBuffer(file);

      } catch (error) {
        console.error('Error:', error);
        showStatusMessage('Error processing PDF file', 'error');
        resetLoadingState();
      }
    }

    // Render PDF page
    async function renderPage(num) {
      if (!pdfDoc) return;
      
      try {
        const page = await pdfDoc.getPage(num);
        const viewport = page.getViewport({ scale: scale });

        canvas.width = viewport.width;
        canvas.height = viewport.height;
        container.style.width = viewport.width + 'px';
        container.style.height = viewport.height + 'px';

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const renderContext = {
          canvasContext: ctx,
          viewport: viewport,
        };
        
        await page.render(renderContext).promise;
        drawCropBoxes();
        
        // Update page info
        pageInfo.textContent = `Page ${currentPage} of ${pdfDoc.numPages}`;
        updateZoom();
        
      } catch (error) {
        console.error('Error rendering page:', error);
        showStatusMessage('Error rendering PDF page', 'error');
      }
    }

    // Draw all crop boxes on top
    function drawCropBoxes() {
      // Remove existing div crop boxes
      [...container.querySelectorAll('.crop-area')].forEach(el => el.remove());

      cropBoxes.forEach((box, idx) => {
        const div = document.createElement('div');
        div.classList.add('crop-area');
        if (idx === selectedBoxIndex) div.classList.add('selected');
        div.style.left = box.left + 'px';
        div.style.top = box.top + 'px';
        div.style.width = box.width + 'px';
        div.style.height = box.height + 'px';
        div.dataset.index = idx;

        // Add resize handles
        ['nw', 'ne', 'sw', 'se'].forEach(handle => {
          const h = document.createElement('div');
          h.classList.add('handle', handle);
          h.dataset.handle = handle;
          div.appendChild(h);
        });

        container.appendChild(div);
      });
    }

    // Save state for undo
    function saveState() {
      undoStack.push(JSON.stringify(cropBoxes));
      if (undoStack.length > 50) undoStack.shift(); // limit undo stack
      redoStack = [];
      updateUndoRedoButtons();
    }

    // Undo action
    function undoAction() {
      if (undoStack.length === 0) return;
      redoStack.push(JSON.stringify(cropBoxes));
      const lastState = undoStack.pop();
      cropBoxes = JSON.parse(lastState);
      selectedBoxIndex = -1;
      drawCropBoxes();
      updateUndoRedoButtons();
    }

    // Redo action
    function redoAction() {
      if (redoStack.length === 0) return;
      undoStack.push(JSON.stringify(cropBoxes));
      const redoState = redoStack.pop();
      cropBoxes = JSON.parse(redoState);
      selectedBoxIndex = -1;
      drawCropBoxes();
      updateUndoRedoButtons();
    }

    function updateUndoRedoButtons() {
      undoBtn.disabled = undoStack.length === 0;
      redoBtn.disabled = redoStack.length === 0;
    }

    function clearUndoRedo() {
      undoStack = [];
      redoStack = [];
      updateUndoRedoButtons();
    }

    // Update page navigation buttons
    function updatePageNavigation() {
      prevPageBtn.disabled = currentPage <= 1;
      nextPageBtn.disabled = currentPage >= pdfDoc.numPages;
    }

    // Go to previous page
    function goToPrevPage() {
      if (currentPage > 1) {
        currentPage--;
        renderPage(currentPage);
        updatePageNavigation();
      }
    }

    // Go to next page
    function goToNextPage() {
      if (currentPage < pdfDoc.numPages) {
        currentPage++;
        renderPage(currentPage);
        updatePageNavigation();
      }
    }

    // Apply crop and download cropped PDF
    async function applyCrop() {
      if (!pdfDoc) {
        showStatusMessage('Please upload a PDF first', 'error');
        return;
      }

      if (cropBoxes.length === 0) {
        showStatusMessage('Please draw at least one crop box', 'error');
        return;
      }

      try {
        loadingSpinner.style.display = 'block';
        applyCropBtn.disabled = true;

        const pagesToCrop = pageSelect.value === 'all' ? [...Array(pdfDoc.numPages).keys()].map(i => i + 1) : [currentPage];
        const pdfBytes = await pdfDoc.getData();

        const pdfLibDoc = await PDFLib.PDFDocument.load(pdfBytes);
        const croppedPdf = await PDFLib.PDFDocument.create();

        for (const pageNum of pagesToCrop) {
          const page = await pdfDoc.getPage(pageNum);
          const viewport = page.getViewport({ scale: scale });
          const pdfPage = pdfLibDoc.getPage(pageNum - 1);
          const [width, height] = [pdfPage.getWidth(), pdfPage.getHeight()];

          // For simplicity, use the first crop box (or you can adapt to multiple boxes)
          // Convert crop box px (canvas scale) to PDF points:
          let box = cropBoxes[0];

          // PDF coordinate origin is bottom-left; canvas top-left
          const scaleX = width / canvas.width;
          const scaleY = height / canvas.height;

          // Calculate crop rectangle in PDF coordinates
          const cropX = box.left * scaleX;
          const cropY = height - (box.top + box.height) * scaleY;
          const cropWidth = box.width * scaleX;
          const cropHeight = box.height * scaleY;

          // Copy page and set crop box
          const [copiedPage] = await croppedPdf.copyPages(pdfLibDoc, [pageNum - 1]);
          copiedPage.setCropBox(cropX, cropY, cropX + cropWidth, cropY + cropHeight);

          croppedPdf.addPage(copiedPage);
        }

        const pdfDataUri = await croppedPdf.saveAsBase64({ dataUri: true });
        const a = document.createElement('a');
        a.href = pdfDataUri;
        a.download = 'cropped.pdf';
        a.click();

        showStatusMessage('PDF cropped and downloaded successfully!', 'success');

      } catch (error) {
        console.error('Error cropping PDF:', error);
        showStatusMessage('Error cropping PDF file', 'error');
      } finally {
        loadingSpinner.style.display = 'none';
        applyCropBtn.disabled = false;
      }
    }

    // Mouse events for drawing, selecting, dragging and resizing crop boxes
    container.addEventListener('mousedown', e => {
      // Ignore if clicking outside canvas container or if no PDF loaded
      if (!pdfDoc) return;

      const rect = container.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Check if clicked on a resize handle
      const target = e.target;
      if (target.classList.contains('handle')) {
        // Start resizing selected box
        isResizing = true;
        resizeHandle = target.dataset.handle;
        e.preventDefault();
        return;
      }

      // Check if clicked on a crop box for dragging/selecting
      if (target.classList.contains('crop-area')) {
        selectedBoxIndex = Number(target.dataset.index);
        const box = cropBoxes[selectedBoxIndex];
        dragOffsetX = x - box.left;
        dragOffsetY = y - box.top;
        isDraggingBox = true;
        drawCropBoxes();
        e.preventDefault();
        return;
      }

      // Otherwise, start drawing a new crop box
      selectedBoxIndex = -1;
      isDrawing = true;
      startX = x;
      startY = y;
      cropBoxes.push({ left: startX, top: startY, width: 0, height: 0 });
      selectedBoxIndex = cropBoxes.length - 1;
      drawCropBoxes();
      e.preventDefault();
    });

    container.addEventListener('mousemove', e => {
      if (!pdfDoc) return;
      const rect = container.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (isDrawing) {
        let box = cropBoxes[selectedBoxIndex];
        box.left = Math.min(x, startX);
        box.top = Math.min(y, startY);
        box.width = Math.abs(x - startX);
        box.height = Math.abs(y - startY);
        drawCropBoxes();
      } else if (isDraggingBox && selectedBoxIndex !== -1) {
        let box = cropBoxes[selectedBoxIndex];
        box.left = x - dragOffsetX;
        box.top = y - dragOffsetY;

        // Clamp to canvas
        box.left = Math.min(Math.max(0, box.left), canvas.width - box.width);
        box.top = Math.min(Math.max(0, box.top), canvas.height - box.height);
        drawCropBoxes();
      } else if (isResizing && selectedBoxIndex !== -1) {
        let box = cropBoxes[selectedBoxIndex];
        let minSize = 10; // minimum size for crop box
        let left = box.left;
        let top = box.top;
        let width = box.width;
        let height = box.height;

        switch (resizeHandle) {
          case 'nw':
            // Resize from top-left corner
            let newLeft = Math.min(left + width, Math.max(0, x));
            let newTop = Math.min(top + height, Math.max(0, y));
            width = width + (left - newLeft);
            height = height + (top - newTop);
            if (width >= minSize && height >= minSize) {
              box.left = newLeft;
              box.top = newTop;
              box.width = width;
              box.height = height;
            }
            break;
          case 'ne':
            // Resize from top-right corner
            let newTopNe = Math.min(top + height, Math.max(0, y));
            let newWidthNe = Math.max(minSize, Math.min(canvas.width - left, x - left));
            let newHeightNe = height + (top - newTopNe);
            if (newHeightNe >= minSize) {
              box.top = newTopNe;
              box.width = newWidthNe;
              box.height = newHeightNe;
            }
            break;
          case 'sw':
            // Resize from bottom-left corner
            let newLeftSw = Math.min(left + width, Math.max(0, x));
            let newHeightSw = Math.max(minSize, Math.min(canvas.height - top, y - top));
            let newWidthSw = width + (left - newLeftSw);
            if (newWidthSw >= minSize) {
              box.left = newLeftSw;
              box.width = newWidthSw;
              box.height = newHeightSw;
            }
            break;
          case 'se':
            // Resize from bottom-right corner
            let newWidthSe = Math.max(minSize, Math.min(canvas.width - left, x - left));
            let newHeightSe = Math.max(minSize, Math.min(canvas.height - top, y - top));
            box.width = newWidthSe;
            box.height = newHeightSe;
            break;
        }
        drawCropBoxes();
      }
    });

    window.addEventListener('mouseup', e => {
      if (isDrawing) {
        isDrawing = false;
        // Remove zero-sized boxes
        let box = cropBoxes[selectedBoxIndex];
        if (box.width < 10 || box.height < 10) {
          cropBoxes.splice(selectedBoxIndex, 1);
          selectedBoxIndex = -1;
        }
        saveState();
        drawCropBoxes();
      }
      if (isDraggingBox) {
        isDraggingBox = false;
        saveState();
      }
      if (isResizing) {
        isResizing = false;
        resizeHandle = null;
        saveState();
      }
    });

    // Delete selected crop box on Delete or Backspace key
    window.addEventListener('keydown', e => {
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedBoxIndex !== -1) {
        cropBoxes.splice(selectedBoxIndex, 1);
        selectedBoxIndex = -1;
        saveState();
        drawCropBoxes();
      }
    });

    // Click outside crop boxes deselects
    container.addEventListener('click', e => {
      if (e.target === container || e.target === canvas) {
        selectedBoxIndex = -1;
        drawCropBoxes();
      }
    });

    function resetLoadingState() {
      loadingSpinner.style.display = 'none';
      progressContainer.style.display = 'none';
      progressBar.style.width = '0';
    }

    function showStatusMessage(message, type) {
      try {
        statusMessage.textContent = message;
        statusMessage.className = 'status-message ' + type;
        statusMessage.style.display = 'block';

        // Hide message after 5 seconds
        setTimeout(() => {
          statusMessage.style.display = 'none';
        }, 5000);
      } catch (error) {
        console.error('Error showing status message:', error);
      }
    }

    function resetCropBoxes() {
      cropBoxes = [];
      selectedBoxIndex = -1;
      clearUndoRedo();
      drawCropBoxes();
      showStatusMessage('All crop boxes removed', 'success');
    }

    // Zoom in function
    function zoomIn() {
      if (scale < MAX_SCALE) {
        scale += SCALE_STEP;
        updateZoom();
        renderPage(currentPage);
      }
    }

    // Zoom out function
    function zoomOut() {
      if (scale > MIN_SCALE) {
        scale -= SCALE_STEP;
        updateZoom();
        renderPage(currentPage);
      }
    }

    // Reset zoom to default
    function resetZoom() {
      scale = 1.5;
      updateZoom();
      renderPage(currentPage);
    }

    // Update zoom display
    function updateZoom() {
      zoomValue.textContent = `${Math.round(scale * 100)}%`;
    }

    function toggleTheme() {
      try {
        const newTheme = themeToggle.checked ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', newTheme);

        // Save preference to localStorage
        localStorage.setItem('theme', newTheme);
      } catch (error) {
        console.error('Error toggling theme:', error);
      }
    }

    // Initial render empty
    function init() {
      canvas.width = 600;
      canvas.height = 800;
      ctx.fillStyle = "#eee";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    init();
  </script>
</body>

</html>